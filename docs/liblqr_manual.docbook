<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DOcBook XML V4.5//EN" "/usr/share/xml/docbook/schema/dtd/4.5/docbookx.dtd" [
	<!ENTITY lqr "Liquid Rescale">
	<!ENTITY lqrl "&lqr; library">
	<!ENTITY carv_obj "<classname>LqrCarver</classname>">
	<!ENTITY vmap_obj "<classname>LqrVMap</classname>">
	<!ENTITY prog_obj "<classname>LqrProgress</classname>">
	<!ENTITY ret_true "<literal><returnvalue>TRUE</returnvalue></literal>">
	<!ENTITY ret_false "<literal><returnvalue>FALSE</returnvalue></literal>">
	<!ENTITY ret_null "<literal><returnvalue>NULL</returnvalue></literal>">
	<!ENTITY param_w "<parameter>width</parameter>">
	<!ENTITY param_h "<parameter>height</parameter>">
	<!ENTITY param_bpp "<parameter>bpp</parameter>">
	<!ENTITY param_depth "<parameter>depth</parameter>">
	<!ENTITY err_ok "<literal><errorcode>LQR_OK</errorcode></literal>">
	<!ENTITY err_err "<literal><errorcode>LQR_ERROR</errorcode></literal>">
	<!ENTITY err_nomem "<literal><errorcode>LQR_NOMEM</errorcode></literal>">
	]>


<book id="liblqr-manual" lang="en">

	<bookinfo>
		<title>The &lqrl; Manual</title>
	</bookinfo>

	<chapter id="Introduction">

		<title>Introduction</title>

		<sect1 id="about-this-doc">
			<title>About this document</title>
			<para>
				This manual describes in detail the &lqrl; API, starting
				from a brief overview on seam carving, the internal image representation,
				a minimal list of basic methods and the full explanation of all the
				library public methods.
			</para>
			<para>
				In the `<filename>examples</filename>' directory, you will find a minimal example program,
				which only uses basic methods, and a full-featured demo program,
				which uses almost all of the methods described in this document.
				Both programs are fully commented, see also the <filename>README</filename>
				file in the `<filename>examples</filename>' directory.
			</para>
			<para>
				Refer to the <filename>README</filename> file for information about installing
				and compiling.
			</para>
			<bridgehead id="copyright" renderas="sect1">
			Copyright
			</bridgehead>
			<para>
				LiquidRescaling Library Manual
				Copyright (C) 2007 Carlo Baldassi <email>carlobaldassi@gmail.com</email>
			</para>
			<para>
				Permission is granted to copy, distribute and/or modify this document
				under the terms of the GNU Free Documentation License, Version 1.2
				or any later version published by the Free Software Foundation;
				with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
				Texts.  A copy of the license is included in the section entitled "GNU
				Free Documentation License".
			</para>
			<note>
				The manual reference is not complete yet.
			</note>
		</sect1>

		<sect1 id="seam-carve">
			<title>Seam carving in brief</title>
			<para>
				Basically, the algorithm tries to find out which parts
				of the image are important, and which are not, based on the contrast
				between adjacent pixels; then, the image is resized through the
				elimination or insertion of continuous paths, called `seams'.
				The seams connect the top of the image with the bottom when
				rescaling horizontally, or they connect the left side with the right
				side when rescaling vertically.
				In the seam carving process, seams are removed in sequence.
				The seam insertion process mirrors the seam carving process,
				introducing interpolated seams in regions where they would have
				been carved.
			</para>
			<para>
				It often happens that the automatic feature detection fails
				to identify as significant some image regions; in these cases
				a preservation mask can be specified, which marks those regions.
				In fact, the feature recognition process can be manually driven
				quite easily to its full extent. 
			</para>
			<para>
				See also the <link linkend="references">References</link> section for
				more information about the algorithm.
			</para>

			<sect2 id="about-enlarge">
				<title>About enlarging</title>
				<para>
					As mentioneed above, the enlargment process mirrors the carving
					process. More precisely, in order to enlarge the image by a given
					amount of pixels, say N, the library first computes which would be
					the first N seams to be removed; then, it inserts new seams
					nearby those.
				</para>
				<para>
					This means that it is clearly not possible to go beyond twice the
					original size in a single step. It also means that doubling the
					image size in this way is just equivalent to standard scaling, since
					the result is that each seam is just duplicated. All in all, it is
					not advisable to enlarge too much in a single step.
				</para>
				<para>
					This same issue also affects in a tricky way the preservation of image
					areas when enlarging: suppose your image is 1000 pixels wide,
					and you have protected an area which is 800 pixels wide. It is then
					clear that you cannot shrink the image to less than 800 pixels without
					affecting the preserved area, but the same is true when enlarging,
					so you should not go beyond 1200 pixels (= 1000 + (1000 - 800)).
				</para>
			</sect2>
		</sect1>


		<sect1 id="overview">
			<title>Overview of the library</title>
			<para>
				The &lqrl; is written in C, but can be used into C++ programs without
				any modification.
				It has an object-oriented design, so that the terminology is borrowed
				from C++. The central class of the library is called &carv_obj;.
				Carver objects can generate and store multi-size images, or load
				them, and read them out at the desired size.
			</para>
			<para>
				Internally, multi-size images are stored simply as plain images with the addition
				of a visibility map. Each pixel in the image has its own visibility level.
				We decide whether to display a pixel or not simply by comparing each pixel's
				visibility with a given global visibility level. In this way, we can read
				out images of different sizes, simply by setting properly a global visibility
				level.
			</para>
			<para>
				Once the visibility map has been computed, it allows effortless,
				real-time scaling.
				However, visibility maps also necessarily have an orientation, either
				horizontal or vertical. If we want to resize on the other direction, the
				visibility map has to be computed afresh, and the previous visibility map
				becomes useless, because the two maps are not consistent one with the other.
			</para>
			<para>
				This also implies that the resizing order affects the final result: rescaling
				horizontally first, then vertically, does not yield the same result as following
				the reverse order. Moreover, one could choose an intermediate way, e.g. by
				rescaling by one pixel in one direction, one in the other, then iterating as
				needed to reach the final size.
			</para>
			<para>
				The default behaviour of the library is to rescale horizontally first, then
				vertically, but this order can be reversed.
			</para>
			<para>
				Visibility maps can be stored in objects of type &vmap_obj;.
				When a &carv_obj; object is created from an input image, the
				visibility of each pixel is uninitialized. At this point, one could either
				import a previously computed &vmap_obj;, or activate the &carv_obj; so
				that it creates one afresh when asked.
			</para>
			<para>
				In either case, there's a single method to call, specifiying the new
				desired size; all the rest will automatically be computed as necessary.
				By default, the visibility maps are only computed up to the extent to which
				they are needed for resizing.
			</para>
		</sect1>

		<sect1 id="basic">
			<title>Basic methods</title>
			<para>
				Following is a list of the basic public methods associated
				with the &carv_obj; objects:
			</para>
			<para>
				<itemizedlist>
					<listitem>
						<para>
							constructor and destructor
						</para>
						<para>
							<programlisting>
LqrCarver * lqr_carver_new (guchar *buffer, gint width, gint height, gint bpp);
void lqr_carver_destroy (LqrCarver *carver);
							</programlisting>
						</para>
					</listitem>
					<listitem>
						<para>
							initialization
						</para>
						<para>
							<programlisting>
LqrRetVal lqr_carver_init (LqrCarver *carver, gint delta_x, gfloat rigidity);
							</programlisting>
						</para>
					</listitem>
					<listitem>
						<para>
							image manipulations
						</para>
						<para>
							<programlisting>
LqrRetVal lqr_carver_resize (LqrCarver *carver, gint new_width, gint new_width);
LqrRetVal lqr_carver_flatten (LqrCarver *carver);
							</programlisting>
						</para>
					</listitem>
					<listitem>
						<para>
							readout
						</para>
						<para>
							<programlisting>
gboolean lqr_carver_scan (LqrCarver *carver, gint *x, gint *y, guchar **carvergb);
gboolean lqr_carver_scan_by_row (LqrCarver *carver);
gboolean lqr_carver_scan_line (LqrCarver *carver, gint *n, guchar **carvergb);
							</programlisting>
						</para>
					</listitem>
					<listitem>
						<para>
							get values
						</para>
						<para>
							<programlisting>
gint lqr_carver_get_width (LqrCarver *carver);
gint lqr_carver_get_height (LqrCarver *carver);
gint lqr_carver_get_bpp (LqrCarver *carver);
							</programlisting>
						</para>
					</listitem>

				</itemizedlist>
			</para>
			<para>
				The fastest way to see how they work is having a look at the code
				of <filename>examples/liquidrescale-basic.cpp</filename>, which is
				a very simple and fully commented demostrative program.
			</para>
			<para>
				The return value of many functions is of type <classname>LqrRetVal</classname>. This is just an
				enum type which can be used for signal handling, see <link linkend="signals">this section</link>.
			</para>
			<para>
				The other classes are optional: the class &vmap_obj; is used to hold the
				carving information (and the class <classname>LqrVMapList</classname> is used to retrieve it
				from the &carv_obj; ojects); the class &prog_obj; is used to customize
				progress report from the resizing engine (by default is turned off).
			</para>
			<para>
				A complete list of the library public method can be found at the
				end of this document
			</para>
		</sect1>
	</chapter>

	<chapter id="api-manual">

		<title>API user manual</title>

		<sect1 id="signals">
			<title>Signal handling</title>
			<para>
				Many library functions return a value of type <classname>LqrRetVal</classname>. This is an enum
				type which can hold the values:
				<variablelist>
					<varlistentry>
						<term>&err_ok;</term>
						<listitem>
							<para>
								everyting OK
							</para>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term>&err_err;</term>
						<listitem>
							<para>
								generic <errortype>fatal</errortype> error
							</para>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term>&err_nomem;</term>
						<listitem>
							<para>
								not enough memory
							</para>
						</listitem>
					</varlistentry>
				</variablelist>
			</para>
			<para>
				At top level, the user should handle this values explicitely, because
				the library doesn't do anything else than stopping and returning an
				error signal in case of errors. An easy way is setting up some macros
				and wrap each function call with those, as shown in the example files.
			</para>
			<para>
				Below top level, the library provides some convenient macros which can be used
				to wrap function calls, in order to propagate these signals:
				<variablelist>
					<varlistentry>
						<term><literal><function>CATCH</function> (<parameter>expr</parameter>)</literal></term>
						<listitem>
							<para>
								if <parameter>expr</parameter> is equal to &err_ok;	
								it does nothing, otherwise it returns <parameter>expr</parameter>
								(or the result of the execution of <parameter>expr</parameter>
								if it happens to be a function)
							</para>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term><literal><function>CATCH_F</function> (<parameter>expr</parameter>)</literal></term>
						<listitem>
							<para>
								returns &err_err; if
								<parameter>expr</parameter> is <literal>FALSE</literal>
							</para>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term><literal><function>CATCH_MEM</function> (<parameter>expr</parameter>)</literal></term>
						<listitem>
							<para>
								returns &err_nomem; if
								<parameter>expr</parameter> is <literal>NULL</literal>
							</para>
						</listitem>
					</varlistentry>
				</variablelist>
			</para>
		</sect1>

		<sect1 id="generate-multi-size">
			<title>Generating the multi-size image</title>

			<sect2 id="carver-new">
				<title>Carver object creation</title>
				<para>
					The &carv_obj; objects are initialized from a plain buffer of unsigned
					chars representing an image, in which each colour channel takes a value
					between 0 and 255, through this function:
					<funcsynopsis>
						<funcprototype>
							<funcdef>LqrCarver * <function>lqr_carver_new</function></funcdef>
							<paramdef> guchar * <parameter>buffer</parameter></paramdef>
							<paramdef> gint <parameter>width</parameter></paramdef>
							<paramdef> gint <parameter>height</parameter></paramdef>
							<paramdef> gint <parameter>bpp</parameter></paramdef>
						</funcprototype>
					</funcsynopsis>
				</para>
				<para>
					Here, <parameter>buffer</parameter> is the array representing an image of size
					<parameter>width</parameter> by <parameter>height</parameter> width
					<parameter>bpp</parameter> colour channels per pixels.
					Thus, the overall buffer size has to be of
					<literal><parameter>widht</parameter> * <parameter>height</parameter> * <parameter>bpp</parameter>
					</literal>
					unsigned characters, and ordered such that
					the <literal><symbol>k</symbol></literal>-th colour of the pixel at row
					<literal><symbol>y</symbol></literal> and column
					<literal><symbol>x</symbol></literal> is found at:
					<programlisting>buffer[(y * width + x) * bpp + k]</programlisting>
					(this assumes that <literal><symbol>x</symbol></literal>, <literal><symbol>y</symbol></literal>
					and <literal><symbol>k</symbol></literal> all start from <literal>0</literal>
					and reach the maximum values
					<literal><symbol>widht</symbol>-1</literal>,
					<literal><symbol>height</symbol>-1</literal>
					and <literal><symbol>bpp</symbol>-1</literal>, respectively)
				</para>
				<para>
					The function returns a pointer to the newly allocated &carv_obj; upon 
					success, or <literal><returnvalue>NULL</returnvalue></literal> in case of insufficient memory.
				</para>
				<important>
					<para>
						The buffer will be incorporated into the &carv_obj; object and
						must not be accessed directly any more.
					</para>
				</important>
			</sect2>

			<sect2 id="carver-init">
				<title>Carver activation</title>
				<para>
					The newly created &carv_obj; consists only of the image buffer plus
					an uninitialized visibility map. If one had a previously computed
					visibility map, it could be imported into the &carv_obj; and that would be
					enough (see the <link linkend="import-vmap">Importing a visibility map
							in a carver</link> section).

					If the visibility map has to be computed, the &carv_obj; needs to be
					initialized through this function:

					<funcsynopsis>
						<funcprototype>
							<funcdef>LqrRetVal <function>lqr_carver_init</function></funcdef>
							<paramdef> LqrCarver * <parameter>carver</parameter></paramdef>
							<paramdef> gint <parameter>delta_x</parameter></paramdef>
							<paramdef> gfloat <parameter>rigidity</parameter></paramdef>
						</funcprototype>
					</funcsynopsis>
				</para>
				<para>
					Here, <parameter>delta_x</parameter> is the maximum allowed transversal step of the
					seams (0 means straight seams, the standard value is 1), while
					the <parameter>rigidity</parameter> parameter can be used to introduce
					a bias for non-straight seams (the standard value is 0).
			</para>
				<important>
					<para>
						It is currently an error to initalize a carver object
						if a visibility map has been imported already.
					</para>
				</important>
			</sect2>


		</sect1>

		<sect1 id="lqr">
			<title>Liquid rescaling</title>

			<sect2 id="lqr-resize">
				<title>The resizing method</title>
				<para>
					Once initialized, or if a visibility map has been loaded, the image can be
					resized through this function:
					<funcsynopsis>
						<funcprototype>
							<funcdef>LqrRetVal <function>lqr_carver_resize</function></funcdef>
							<paramdef> LqrCarver * <parameter>carver</parameter></paramdef>
							<paramdef> gint <parameter>new_width</parameter></paramdef>
							<paramdef> gint <parameter>new_height</parameter></paramdef>
						</funcprototype>
					</funcsynopsis>
				</para>
				<para>
					This function decides automatically whether it can use the already computed
					visibility map, it has to update it or waste it completely and start
					afresh. This last event occurs when the map was computed for horizontal
					resizing and a vertical resize has been requested, or vice versa.
					Note that only initialized carvers can update or change the visibility
					map; if this is not the case, an error is returned.
				</para>
				<para>
					The function also takes advantage of the fact that the enlargment process
					mirrors the shrink process. For example, if the original size of the image
					is <literal>(<symbol>w0</symbol>, <symbol>h0</symbol>)</literal> and
					<function>lqr_carver_resize</function> is invoked with
					<literal>(<symbol>w0</symbol> - 100, <symbol>h0</symbol>)</literal> as an
					argument, then subsequent calls to the function will allow on-the-fly
					resizing in the whole range from
					<literal>(<symbol>w0</symbol> - 100, <symbol>h0</symbol>)</literal> to
					<literal>(<symbol>w0</symbol> + 100, <symbol>h0</symbol>)</literal>.
				</para>
				<important>
					<para>
						It is an error to ask for a size greater than twice the initial
						size in one step. See also the section
						<link linkend="about-enlarge">About enlarging</link>.
					</para>
				</important>
			</sect2>

			<sect2 id="flatten">
				<title>Flattening</title>
				<para>
					In order to resize in more than one step, the image can be flattened in
					its current state, thrugh this function:
					<funcsynopsis>
						<funcprototype>
							<funcdef>gboolean <function>lqr_carver_flatten</function></funcdef>
							<paramdef> LqrCarver * <parameter>carver</parameter></paramdef>
						</funcprototype>
					</funcsynopsis>
				</para>
				<para>
					The return value is &ret_false; in case
					of insufficient memory, &ret_true; otherwise.
				</para>
				<para>
					This function destroys the current visibility map and reinitializes
					the multi-size image from its current state.
				</para>
				<note>
					<para>
						Every time that the image is flattened (including when changing
						the resize direction) the original image is lost.
					</para>
				</note>
			</sect2>
		</sect1>

		<sect1 id="read-out">
			<title>Reading the multi-size image</title>

			<sect2 id="px-by-px">
				<title>Pixel by pixel</title>

				<para>
					Once you have rescaled the image, you can read out the result through
					this function:
					<funcsynopsis>
						<funcprototype>
							<funcdef>gboolean <function>lqr_carver_scan</function></funcdef>
							<paramdef> gint* <parameter>x</parameter></paramdef>
							<paramdef> gint* <parameter>y</parameter></paramdef>
							<paramdef> guchar** <parameter>rgb</parameter></paramdef>
						</funcprototype>
					</funcsynopsis>

				</para>
				<para>
					Here, <parameter>x</parameter> and <parameter>y</parameter> are pointers to
					the varaibles which will hold the pixel coordinate, while 
					<parameter>rgb</parameter> is a pointer to an array which will
					contain the pixel colour information.
				</para>
				<para>
					The return value is &ret_false; when the end of the image is reached,
					&ret_true; otherwise.
				</para>
				<para>
					Each time this function is invoked, it will store
					the coordinates and rgb information in the output pointers
					and move to the next pixel. If it reaches the end, it
					resets the reader and returns &ret_false;.
				</para>
				<para>
					Here is a sample code usage:
					<example id="ex-read-out">
						<title>A simple readout example</title>
						<programlisting>
gint x, y;
guchar *rgb;

while (lqr_carver_scan (carver, &amp;x, &amp;y, &amp;rgb)
  {
    my_plot (x, y, rgb[0], rgb[1], rgb[2]);
  }
						</programlisting>
					</example>

					In this example, it is assumed that the image has 3 colour
					channels, and that there exist some function
					<function>my_plot</function> which writes out the pixels somewhere.
				</para>
				<important>
					<para>
						The <parameter>rgb</parameter> array is internal
						to the carver object, so it doesn't need initialization
						(but don't use pointers to it or its elements, always copy
						the contents as in the example).
					</para>
				</important>
			</sect2>

			<sect2 id="line-by-line">
				<title>One line at a time</title>

				<para>
					The image can also be read one line at a time, but it is
					not possible to freely decide if it is to be read by row or
					by column. Instead, this has to be queried by calling this
					function: 
					<funcsynopsis>
						<funcprototype>
							<funcdef>gboolean <function>lqr_carver_scan_by_row</function></funcdef>
							<paramdef>LqrCarver* <parameter>carver</parameter></paramdef>
						</funcprototype>
					</funcsynopsis>
				</para>

				<para>
					The function returns &ret_true; if the image is read by row, and &ret_false;
					if it is read by column.
				</para>
				<para>
					Then, the image can be read through this function:
					<funcsynopsis>
						<funcprototype>
							<funcdef>gboolean <function>lqr_carver_scan_line</function></funcdef>
							<paramdef>LqrCarver* <parameter>carver</parameter></paramdef>
							<paramdef>gint* <parameter>n</parameter></paramdef>
							<paramdef>guchar** <parameter>rgb</parameter></paramdef>
						</funcprototype>
					</funcsynopsis>
				</para>
				<para>
					This function works exactly the same way as <function>lqr_carver_scan</function>, but
					only one coordinate is stored (either the row or the column number),
					and the <parameter>rgb</parameter> array will contain a whole line.
				</para>
				<para>
					Here is a sample code usage:
					<example id="ex-scan-line">
						<title>Line-by-line readout example</title>
						<programlisting>
gint n;
guchar *rgb;
gboolean by_row;

by_row = lqr_carver_scan_by_row (carver);

while (lqr_carver_scan_line (carver, &amp;n, &amp;rgb)
  {
    by_row ? my_plot_row (n, rgb) : my_plot_col (n, rgb);
  }
						</programlisting>
					</example>

					where, as before, it is assumed that the
					<function>my_plot_row</function> and
					<function>my_plot_col</function> functions
					have been previously defined and "know what to do".
				</para>
			</sect2>

			<sect2 id="reset">
				<title>Resetting</title>

				<para>
					Normally, it is not needed to reset the image scan. However, if the
					scan has been stopped at same intermediate step for some reason, the
					following function can be used to restart from the beginning:
					<funcsynopsis>
						<funcprototype>
							<funcdef>void <function>lqr_carver_scan_reset</function></funcdef>
							<paramdef>LqrCarver* <parameter>carver</parameter></paramdef>
						</funcprototype>
					</funcsynopsis>
				</para>
			</sect2>
		</sect1>

		<sect1 id="bias">
			<title>Adding a bias</title>

			<sect2 id="foreword">
				<title>Foreword</title>

				<para>
					The automatic feature detection can be driven manually by
					adding a bias to the pixels of the image.
				</para>
				<para>
					For example, it is possible to protect regions of the image by
					adding a positive bias to the corresponding pixels. This will
					make the seams more unlikely to cross those regions, thus
					avoiding distortion (but increasing distortion of the other
					regions).
				</para>
				<para>
					It is also possible to make the seams more likely to cross some
					regions by adding a negative bias to them. In this case, reducing
					the size of the image will tend to erase those regions, while
					(possibly) keeping the rest of the image in a consistent state. 
				</para>
				<important>
					<para>
						The bias has to be added always <emphasis>after</emphasis>
						the &carv_obj; initialization and <emphasis>before</emphasis>
						resizing takes place.
					</para>
				</important>
				<note>
					<para>
						In all of the bias-related functions, the bias is
						added on top of the existing one, so that all of the functions
						can be called multiple times.
					</para>
				</note>
				<para>

					(See also the section "Additional notes" in the README file for
					situations where the behaviour of biased regions can be
					counter-intuitive.) [XXX]
				</para>
			</sect2>

			<sect2 id="float-bias">
				<title>Using an array of floating-point values</title>

				<para>
					The bias values are stored as an array of floating points.
					It is possible to use directly one such array through
					this function:
					<funcsynopsis>
						<funcprototype>
							<funcdef>LqrRetVal <function>lqr_carver_bias_add</function></funcdef>
							<paramdef>LqrCarver* <parameter>carver</parameter></paramdef>
							<paramdef>gdouble* <parameter>buffer</parameter></paramdef>
							<paramdef>gint <parameter>bias_factor</parameter></paramdef>
						</funcprototype>
					</funcsynopsis>
				</para>
				<para>
					Here, <parameter>buffer</parameter> is an array contining the bias values,
					and it is assumed to have the same size as the image loaded in
					<parameter>carver</parameter>, while <parameter>bias_factor</parameter> is an
					overall bias factor, which can be used to affect the global
					bias level: if the elements of buffer are of order 1, a standard
					choice for the bias_factor would be between 100 and 1000.
				</para>
				<note>
					<para>
						This function, and all the following, will not swallow
						the buffer (to the contrary of what happens e.g. when creating
						a new &carv_obj; object).
					</para>
				</note>
			</sect2>

			<sect2 id="bias-rgb">
				<title>Using another image</title>

				<para>
					The bias can also be read from an rgb buffer. This buffer
					has to be in the same format as the one used in the LqrCarver
					constructor (but may have a different number of colour per
					channel). The function is:
					<funcsynopsis>
						<funcprototype>
							<funcdef>LqrRetVal <function>lqr_carver_bias_add_rgb</function></funcdef>
							<paramdef>LqrCarver* <parameter>carver</parameter></paramdef>
							<paramdef>guchar* <parameter>buffer</parameter></paramdef>
							<paramdef>gint <parameter>bias_factor</parameter></paramdef>
							<paramdef>gint <parameter>bpp</parameter></paramdef>
						</funcprototype>
					</funcsynopsis>
				</para>
				<para>
					As in the previous case, <parameter>buffer</parameter> is assumed to
					hold and image of the same size as the one in the <parameter>carver</parameter>.
				</para>
				<para>
					The <parameter>buffer</parameter> contents will be transformed into
					floating-points by averaging the colour components and multiplying the
					result by the alpha channel (transparency) value.
				</para>
				<important>
					<para>
						The existence of an alpha channel is inferred from the
						<parameter>bpp</parameter> value: if this is 1 or 3, no alpha
						channel is assumed, if it is 2 or 4, it is assumed that the last
						channel is holds the alpha value.
					</para>
				</important>
			</sect2>

			<sect2 id="areas">
				<title>Operating on a specific area</title>

				<para>
					The above functions operate on the whole &carv_obj; image.
					It is also possible to access specific image regions; for
					the floating point use:
					<funcsynopsis>
						<funcprototype>
							<funcdef>LqrRetVal <function>lqr_carver_bias_add_area</function></funcdef>
							<paramdef>LqrCarver* <parameter>carver</parameter></paramdef>
							<paramdef>gdouble* <parameter>buffer</parameter></paramdef>
							<paramdef>gint <parameter>bias_factor</parameter></paramdef>
							<paramdef>gint <parameter>width</parameter></paramdef>
							<paramdef>gint <parameter>height</parameter></paramdef>
							<paramdef>gint <parameter>x_off</parameter></paramdef>
							<paramdef>gint <parameter>y_off</parameter></paramdef>
						</funcprototype>
					</funcsynopsis>
					while for the rgb image use:
					<funcsynopsis>
						<funcprototype>
							<funcdef>LqrRetVal <function>lqr_carver_bias_add_rgb_area</function></funcdef>
							<paramdef>LqrCarver* <parameter>carver</parameter></paramdef>
							<paramdef>gdouble* <parameter>buffer</parameter></paramdef>
							<paramdef>gint <parameter>bias_factor</parameter></paramdef>
							<paramdef>gint <parameter>bpp</parameter></paramdef>
							<paramdef>gint <parameter>width</parameter></paramdef>
							<paramdef>gint <parameter>height</parameter></paramdef>
							<paramdef>gint <parameter>x_off</parameter></paramdef>
							<paramdef>gint <parameter>y_off</parameter></paramdef>
						</funcprototype>
					</funcsynopsis>
				</para>
				<para>
					In both functions, &param_w; and &param_h;
					are used to specify the size of the area of interest, while
					<parameter>x_off</parameter> and <parameter>y_off</parameter>
					specify its offset.
					For the rest, both functions work in the same way as their global couterpart.
				</para>
				<para>
					The provided buffers have to be of size
					<literal>&param_w; * &param_h;</literal>
					(or <literal>&param_w; * &param_h; * &param_bpp;</literal> for the rgb case)
					but the specified areas need not to be strictly included inside the
					&carv_obj; image area : only the parts which overlap with it will be used.
					For example, the offsets can also be negative.
				</para>
			</sect2>
		</sect1>

		<sect1 id="tuning">
			<title>Tuning</title>

			<para>
				The behaviour can be tuned through some additional functions.
			</para>


			<sect2 id="gradient">
				<title>Choosing a gradient function</title>

				<para>
					The automatic feature detection relies on the computation
					of the gradient in each pixel of the image. The function to use
					can be set through:
					<funcsynopsis>
						<funcprototype>
							<funcdef>void <function>lqr_carver_set_gradient_function</function></funcdef>
							<paramdef>LqrCarver* <parameter>carver</parameter></paramdef>
							<paramdef>LqrGradFuncType <parameter>gf_ind</parameter></paramdef>
						</funcprototype>
					</funcsynopsis>
				</para>
				<para>
					The possible values for gf_ind are:
					<variablelist>
						<varlistentry>
							<term><literal>LQR_GF_XABS</literal></term>
							<listitem>
								<para>
									transversal absolute value (this is the default)
								</para>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><literal>LQR_GF_NORM</literal></term>
							<listitem>
								<para>
									gradient norm
								</para>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><literal>LQR_GF_SUMABS</literal></term>
							<listitem>
								<para>
									sum of absolute values
								</para>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><literal>LQR_GF_NULL</literal></term>
							<listitem>
								<para>
									null
								</para>
							</listitem>
						</varlistentry>
					</variablelist>
				</para>
				<para>
					The null value can be used to override completely the automatic
					feature detection (see the <link linkend="bias">Adding a bias</link>
					section).
				</para>
			</sect2>

			<sect2 id="res-order">
				<title>Choosing the resize order</title>

				<para>
					When <function>lqr_carver_resize</function> is asked to resize along both directions
					in a single step, it has to choose which direction to resize first.
					The resize order can be changed through this function:
					<funcsynopsis>
						<funcprototype>
							<funcdef>void <function>lqr_carver_set_resize_order</function></funcdef>
							<paramdef>LqrCarver* <parameter>carver</parameter></paramdef>
							<paramdef>LqrResizeOrder <parameter>resize_order</parameter></paramdef>
						</funcprototype>
					</funcsynopsis>
				</para>
				<para>
					The possible values for resize_order are:
					<variablelist>
						<varlistentry>
							<term><literal>LQR_RES_ORDER_HOR</literal></term>
							<listitem>
								<para>
									resize horizonally first (this is the default) 
								</para>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><literal>LQR_RES_ORDER_VERT</literal></term>
							<listitem>
								<para>
									resize vertically first
								</para>
							</listitem>
						</varlistentry>
					</variablelist>
				</para>
			</sect2>
		</sect1>

		<sect1 id="vmaps">
			<title>Dealing with the visibility maps (the seams)</title>

			<sect2 id="vmap-dump">
				<title>Dumping the visibility map</title>

				<para>
					The visibility map can be saved at any moment by
					calling the function:
					<funcsynopsis>
						<funcprototype>
							<funcdef>LqrVMap* <function>lqr_vmap_dump</function></funcdef>
							<paramdef>LqrCarver* <parameter>carver</parameter></paramdef>
						</funcprototype>
					</funcsynopsis>
				</para>
				<para>
					This function will return a pointer to a newly allocated &vmap_obj; object,
					or &ret_null; in case of failure. See also the section
					"<link linkend="vmaps-objs">The visibility map objects</link>".
				</para>
			</sect2>

			<sect2 id="activate-dump">
				<title>Storing the visibility maps</title>

				<para>
					By default, the computed visibility maps are wasted. Instead
					of saving them individually, it is possible to automatically
					dump them at the end of the carving process, attaching them
					to their associated &carv_obj;. In order to activate
					this feature, the following function has to be called:
					<funcsynopsis>
						<funcprototype>
							<funcdef>void <function>lqr_carver_set_dump_vmaps</function></funcdef>
							<paramdef>LqrCarver* <parameter>carver</parameter></paramdef>
						</funcprototype>
					</funcsynopsis>
				</para>
				<para>
					This will have the effect of dumping the visibility
					map each time <function>lqr_carver_resize</function>
					is invoked, and storing it internally.
					When resizing along both directions,
					two maps will be dumped, one for each direction.
				</para>
				<para>
					Alternatively, the internal storage mechanism
					can be called over the current visibility map
					at any given moment by calling this function:
					<funcsynopsis>
						<funcprototype>
							<funcdef>LqrRetVal <function>lqr_vmap_internal_dump</function></funcdef>
							<paramdef>LqrCarver* <parameter>carver</parameter></paramdef>
						</funcprototype>
					</funcsynopsis>
				</para>
				<para>
					The dumped maps are stored inside &vmap_obj;
					objects, and these are attached to their corresponing
					&carv_obj; object through a linked list, whose
					type is <classname>LqrVMapList</classname>.
				</para>
			</sect2>

			<sect2 id="access-vmap">
				<title>Accessing the internally attached visibility maps</title>

				<para>
					To access the maps attached to a carver one has
					first to obtain the pointer to the list, with the
					function:
					<funcsynopsis>
						<funcprototype>
							<funcdef>LqrVMapList* <function>lqr_vmap_list_start</function></funcdef>
							<paramdef>LqrCarver* <parameter>carver</parameter></paramdef>
						</funcprototype>
					</funcsynopsis>
				</para>
				<para>
					Then, one can iterate through the attached maps by using
					these two functions:
					<funcsynopsis>
						<funcprototype>
							<funcdef>LqrVMap* <function>lqr_vmap_list_current</function></funcdef>
							<paramdef>LqrVMapList* <parameter>list</parameter></paramdef>
						</funcprototype>
					</funcsynopsis>
					<funcsynopsis>
						<funcprototype>
							<funcdef>LqrVMapList* <function>lqr_vmap_list_next</function></funcdef>
							<paramdef>LqrVMapList* <parameter>list</parameter></paramdef>
						</funcprototype>
					</funcsynopsis>
				</para>
				<para>
					Here is a sample code usage:
					<example id="ex-vmaplist1">
						<title>Accessing visibility maps #1</title>

						<programlisting>

LqrVMap *vmap;
LqrVMapList *list;

list = lqr_vmap_list_start (carver);
while (list)
  {
    vmap = lqr_vmap_list_current (list);
    [ ... do something on vmap ... ]
    list = lqr_vmap_list_next (list);
  }
						</programlisting>
					</example>
				</para>
				<para>
					The maps will always be accessed in the order in which they were dumped.
				</para>
				<para>
					Alternatively, one can apply a function to all the elements of
					the list, through this function:
					<funcsynopsis>
						<funcprototype>
							<funcdef>LqrRetVal <function>lqr_vmap_list_foreach</function></funcdef>
							<paramdef>LqrVMapList* <parameter>list</parameter></paramdef>
							<paramdef>LqrVMapFunc <parameter>func</parameter></paramdef>
							<paramdef>gpointer <parameter>data</parameter></paramdef>
						</funcprototype>
					</funcsynopsis>
				</para>
				<para>
					To use this second method, you'll need to define a function first, as in this
					sample code:
					<example id="ex-vmaplist2">
						<title>Accessing visibility maps #2</title>
						<programlisting>
LqrRetVal my_func (LqrVMap vmap, gpointer data)
  {
    [... do something on vmap ... ]
    return LQR_OK;
  }

LqrVMapList *list;

list = lqr_vmap_list_start (carver);
lqr_vmap_list_foreach (list, my_func, NULL);
						</programlisting>
					</example>
				</para>
				<para>
					In the above example, no data is actually passed on to the
					function.
				</para>
				<note>
					<para>
						In actual code the call to <function>lqr_vmap_list_foreach</function>
						should be protected to test its return value, which is 
						&err_ok; if all <function>my_func</function> calls have been successful,
						or it will hold the first non-successful return value from
						<function>my_func</function>.
					</para>
				</note>
			</sect2>

			<sect2 id="vmaps-objs">
				<title>The visibility map objects</title>

				<para>
					The &vmap_obj; objects contain an int buffer
					with the actual map data (plain array, ordered by row),
					plus all the information needed to be able to recover it from scratch.
				</para>
				<para>
					The information can be extracted with these functions:

					<programlisting>
gint* <function>lqr_vmap_get_data</function> (&vmap_obj;* <parameter>vmap</parameter>);
gint <function>lqr_vmap_get_width</function> (&vmap_obj;* <parameter>vmap</parameter>);
gint <function>lqr_vmap_get_height</function> (&vmap_obj;* <parameter>vmap</parameter>);
gint <function>lqr_vmap_get_orientation</function> (&vmap_obj;* <parameter>vmap</parameter>);
gint <function>lqr_vmap_get_depth</function> (&vmap_obj;* <parameter>vmap</parameter>);
					</programlisting>

				</para>
				<para>
					The first one returns a pointer to the data buffer.
				</para>
				<para>
					The orientation of the map is 0 if the map is to be used for
					horizontal rescaling, 1 otherwise.
				</para>
				<para>
					The depth of the map is the maximum amount of rescaling
					possible with that map, either shrinking or enlarging.
				</para>
				<para>
					<example id="vmap-data">
						<title>Reading visibility maps data</title>
						<para>
							If we have a &vmap_obj; pointer called
							<parameter>vmap</parameter>,
							we could access the value at
							<literal>(<symbol>x</symbol>,<symbol>y</symbol>)</literal>
							by:
						</para>
						<programlisting>
gint *buffer;
gint width;
gint vis;

buffer = lqr_vmap_get_data (vmap);
width = lqr_vmap_get_width (vmap);
vis =  buffer[y * width + x];
						</programlisting>
						<para>
							Uninitialized points will yield
							<literal><symbol>vis</symbol> = 0</literal>.
							For initialized points, <symbol>vis</symbol> will store a
							positive value between <literal>1</literal> (least visible points,
							the first to be carved away or to be duplicated) and
							<literal>(&param_depth; + 1)</literal>
							(most visible points, the last to be carved away or to
							be duplicated).
						</para>
						<para>
							If the orientation is 0, the map allows resizing in the
							whole range form <literal>(&param_w; - &param_depth;)</literal>
							to <literal>(&param_w; + &param_depth;)</literal>.
							If the orientation is 1, the analogue formula holds
							with &param_h; in place of &param_w;.
						</para>
					</example>
				</para>
			</sect2>

			<sect2 id="import-vmap">
				<title>Importing a visibility map in a carver</title>

				<para>
					Having an &vmap_obj; object, one can load it in a &carv_obj;
					simply by calling this function:
					<funcsynopsis>
						<funcprototype>
							<funcdef>LqrRetVal <function>lqr_vmap_load</function></funcdef>
							<paramdef>LqrCarver* <parameter>carver</parameter></paramdef>
							<paramdef>LqrVMap* <parameter>vmap</parameter></paramdef>
						</funcprototype>
					</funcsynopsis>
				</para>
				<para>
					The carver must not to be initialized.
				</para>
				<note>
					<para>
						This implies that the map cannot be updated, and
						that it will only be possible to resize the carver by an
						amount &param_depth; along the orientation
						given by <function>lqr_vmap_orientation</function>.
						Invoking <function>lqr_carver_resize</function> with an
						out-of-bounds argument results in a <errortype>fatal</errortype> error
						(i.e. it returns &err_err;)
					</para>
				</note>
				<note>
					<para>
						Do not attach other carvers after you have loaded
						a visibility map (see also the
						<link linkend="attach-images">Attaching extra images</link>
						section).
					</para>
				</note>
			</sect2>

			<sect2 id="save-load-vmaps">
				<title>Saving and loading visibility maps to/from files</title>

				<para>
					The library does not include methods to load/save
					visibility maps to/from files. However, a way to do so
					is included in the demo program
					`<application>liquidrescale</application>' in the
					`<filename>examples</filename>' directory.
				</para>
			</sect2>
		</sect1>

		<sect1 id="attach-images">
			<title>Attaching extra images</title>

			<sect2 id="attach-carver">
				<title>Attaching a carver</title>

				<para>
					Given an &carv_obj; object, it is possible to attach an
					arbitrary number of extra carvers to it: these will
					passively undergo the same carving process as the root
					carver. In order for this to be possible, the carvers
					must be all of the same size.
				</para>
				<para>
					The function to use is simply:
					<funcsynopsis>
						<funcprototype>
							<funcdef>LqrRetVal <function>lqr_carver_attach</function></funcdef>
							<paramdef>LqrCarver* <parameter>carver</parameter></paramdef>
							<paramdef>LqrCarver* <parameter>aux</parameter></paramdef>
						</funcprototype>
					</funcsynopsis>
				</para>
				<para>
					This attaches <parameter>aux</parameter> to
					<parameter>carver</parameter>.
				</para>
				<para>
					It is not necessary that the parent &carv_obj; is activated. In
					fact, a carver can be attached to a carver which is itself
					attached to another one.
				</para>
				<para>
					Needless to say, no resizing operation should be done directly
					on a &carv_obj; once it has been attached to another &carv_obj;.
				</para>
				<important>
					<para>
						The carvers always have to be attached
						<emphasis>before</emphasis> loading
						visibility maps.
					</para>
				</important>
			</sect2>

			<sect2 id="access-attached">
				<title>Accessing attached carvers</title>

				<para>
					Attached carvers can be read-out in the same way as their parents.
					There are however also methods to span all them, in a way very similar
					to that in which internally dumped &vmap_obj;'s are accessed, but
					<classname>LqrVMapList</classname>
					objects are substitued in this case by
					<classname>LqrCarverList</classname> objects.
				</para>
				<para>
					First, the starting point of the list has to be retreived through:
					<funcsynopsis>
						<funcprototype>
							<funcdef>LqrCarverList* <function>lqr_carver_list_start</function></funcdef>
							<paramdef>LqrCarver* <parameter>carver</parameter></paramdef>
						</funcprototype>
					</funcsynopsis>
				</para>
				<para>
					Then, one can iterate through the attached carvers by using
					these two functions:
					<funcsynopsis>
						<funcprototype>
							<funcdef>LqrCarver* <function>lqr_carver_list_current</function></funcdef>
							<paramdef>LqrCarverList* <parameter>list</parameter></paramdef>
						</funcprototype>
					</funcsynopsis>
					<funcsynopsis>
						<funcprototype>
							<funcdef>LqrCarverList* <function>lqr_carver_list_next</function></funcdef>
							<paramdef>LqrCarverList* <parameter>list</parameter></paramdef>
						</funcprototype>
					</funcsynopsis>
				</para>
				<para>
					Here is a sample code usage:
					<example id="ex-attach-list1">
						<title>Accessing attached carvers #1</title>
						<programlisting>

LqrCarver *aux;
LqrCarverList *list;

list = lqr_carver_list_start (carver);
while (list)
  {
    aux = lqr_carver_list_current (list);
    [ ... do something on aux ... ]
    list = lqr_carver_list_next (list);
  }
						</programlisting>
					</example>
				</para>
				<para>
					The carvers will always be accessed in the order in which they were dumped.
				</para>
				<para>
					Alternatively, one can apply a function to all the elements of
					the list, through this function:
					<funcsynopsis>
						<funcprototype>
							<funcdef>LqrRetVal <function>lqr_carver_list_foreach</function></funcdef>
							<paramdef>LqrCarverList* <parameter>list</parameter></paramdef>
							<paramdef>LqrCarverFunc <parameter>func</parameter></paramdef>
							<paramdef>LqrDataTok <parameter>data</parameter></paramdef>
						</funcprototype>
					</funcsynopsis>
				</para>
				<para>
					To use this second method, you'll need to define a function first, as in the
					following sample code:
					<example id="ex-attach-list2">
						<title>Accessing attached carvers #2</title>
						<programlisting>
LqrRetVal my_func (LqrCarver *aux, LqrDataTok data)
  {
    [... do something on aux ... ]
    return LQR_OK;
  }

LqrCarverList *list;
LqrDataTok data_tok;

list = lqr_carver_list_start (carver);
data_tok->data = NULL;
lqr_carver_list_foreach (list, my_func, data_tok);
						</programlisting>
					</example>
				</para>
				<para>
					The data to be passed on to the LqrCarverFunc is of type
					<structname>LqrDataTok</structname>.
					This is defined as a union, with the following
					fields:
					<itemizedlist>
						<listitem>
							<para>&carv_obj;* <structfield>carver</structfield></para>
						</listitem>
						<listitem>
							<para><type>gint</type> <structfield>integer</structfield></para>
						</listitem>
						<listitem>
							<para><type>gpointer</type> <structfield>data</structfield></para> 
						</listitem>
					</itemizedlist>
				</para>
				<para>
					In the above example, no data is actually passed on to the
					function.
				</para>
				<note>
					<para>
						In actual code, the call to
						<function>lqr_carver_list_foreach</function> should
						be protected to test its return value, which is
						&err_ok; if all
						my_func calls have been successful, or it will hold the first
						non-successful return value from
						<function>my_func</function>.
					</para>
				</note>
			</sect2>
		</sect1>

		<sect1 id="progress">
			<title>Progress indicators</title>

			<para>
				By default, the resizing performed silently. However,
				it is possible to define progress report functions, to receive
				feedback while the resizing is in progress.
				This is done through the &prog_obj; objects. 
			</para>
			<sect2 id="progress-init">
				<title>Creating and attaching a progress report object</title>
				<para> 
					A &prog_obj; object
					is created through the function:
					<funcsynopsis>
						<funcprototype>
							<funcdef>LqrProgress* <function>lqr_progress_new</function></funcdef>
							<void></void>
						</funcprototype>
					</funcsynopsis>
					and can be associated to a &carv_obj; object through this function:
					<funcsynopsis>
						<funcprototype>
							<funcdef>void <function>lqr_carver_set_progress</function></funcdef>
							<paramdef>LqrCarver* <parameter>carver</parameter></paramdef>
							<paramdef>LqrProgress* <parameter>p</parameter></paramdef>
						</funcprototype>
					</funcsynopsis>
				</para>
			</sect2>

			<sect2 id="progress-set-up">
				<title>Setting up progress hooks</title>
				<para>
					Newly created progress objects are inactive, and need to be set up.
				</para>
				<para>
					First, hook functions have to be set, which specify the action
					to take as the rescaling process starts, progresses, and ends, by using
					the functions:
					<programlisting>
LqrRetVal <function>lqr_progress_set_init</function> (&prog_obj; * <parameter>p</parameter>, LqrProgressFuncInit <parameter>init_func</parameter>)
LqrRetVal <function>lqr_progress_set_update</function> (&prog_obj; * <parameter>p</parameter>, LqrProgressFuncUpdate <parameter>update_func</parameter>)
LqrRetVal <function>lqr_progress_set_end</function> (&prog_obj; * <parameter>p</parameter>, LqrProgressFuncEnd <parameter>end_func</parameter>)
					</programlisting>
					as in this sample piece of code:
					<example id="ex-set-progress">
						<title>Setting progress hooks</title>
						<programlisting>
LqrProgress *p;

p = lqr_progress_new();
lqr_progress_set_init (p, my_init);
lqr_progress_set_update (p, my_update);
lqr_progress_set_end (p, my_end);
						</programlisting>
					</example>
				</para>
				<para>
					The above example requires that the hook functions
					<function>my_init</function>, <function>my_update</function> and 
					<function>my_end</function>
					are defined as in the following sample declarations:
					<example id="ex-hook-decl">
						<title>Progress hooks declaration</title>
						<programlisting>
LqrRetVal my_init (const gchar *init_message);
LqrRetVal my_update (gdouble percentage);
LqrRetVal my_end (const gchar *end_message);
						</programlisting>
					</example>
				</para>
			</sect2>

			<sect2 id="progress-messages">
				<title>Progress report messages</title>
				<para>
					The init and end messages that will be passed to the hooks will change,
					depending if the resizing is occurring in the horizontal or in the
					vertical direction. The defaults are:
					<table id="progress-mess-def">
						<title>Default progress messages</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry></entry>
									<entry>init</entry>
									<entry>end</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry>width</entry>
									<entry><computeroutput>"Resizing width..."</computeroutput></entry>
									<entry><computeroutput>"done"</computeroutput></entry>
								</row>
								<row>
									<entry>height</entry>
									<entry><computeroutput>"Resizing height..."</computeroutput></entry>
									<entry><computeroutput>"done"</computeroutput></entry>
								</row>
							</tbody>
						</tgroup>
					</table>

					These can be changed with these functions:
					<programlisting>
LqrRetVal <function>lqr_progress_set_init_width_message</function> (&prog_obj; *<parameter>p</parameter>, const gchar * <parameter>message</parameter>)
LqrRetVal <function>lqr_progress_set_init_height_message</function> (&prog_obj; *<parameter>p</parameter>, const gchar * <parameter>message</parameter>)
LqrRetVal <function>lqr_progress_set_end_width_message</function> (&prog_obj; *<parameter>p</parameter>, const gchar * <parameter>message</parameter>)
LqrRetVal <function>lqr_progress_set_end_height_message</function> (&prog_obj; *<parameter>p</parameter>, const gchar * <parameter>message</parameter>)
					</programlisting>
				</para>
			</sect2>

			<sect2 id="progress-upd-step">
				<title>Progress update step</title>
				<para>
					The update hook will receive as an argument the completion percentage.
				</para>
				<para>
					The update step can be specified through:
					<funcsynopsis>
						<funcprototype>
							<funcdef>LqrRetVal <function>lqr_progress_set_update_step</function></funcdef>
							<paramdef>LqrProgress* <parameter>p</parameter></paramdef>
							<paramdef>gfloat <parameter>update_step</parameter></paramdef>
						</funcprototype>
					</funcsynopsis>
				</para>
				<para>
					The default step is 0.02 (i.e. 2%).
				</para>
			</sect2>
		</sect1>

		<sect1 id="release">
			<title>Releasing the memory</title>

			<para>
				&carv_obj; objects can be destroyed using this function:
				<funcsynopsis>
					<funcprototype>
						<funcdef>void <function>lqr_carver_destroy</function></funcdef>
						<paramdef>LqrCarver* <parameter>carver</parameter></paramdef>
					</funcprototype>
				</funcsynopsis>
			</para>
			<para>
				This function also destroys any attached object, thus it should never
				be called on attached carvers.
			</para>
			<para>
				&vmap_obj; objects can be destroyed using this function:
				<funcsynopsis>
					<funcprototype>
						<funcdef>void <function>lqr_vmap_destroy</function></funcdef>
						<paramdef>LqrVMap* <parameter>vmap</parameter></paramdef>
					</funcprototype>
				</funcsynopsis>
			</para>
				
			
		</sect1>
	</chapter>

	<chapter id="ref-pages">
		<title>API reference</title>

		<sect1 id="ref-carve">
			<title>Carver objects</title>

			<refentry id="ref-lqr-carver-new-destroy">
				<refmeta>
					<refentrytitle>&carv_obj; constructor and destructor</refentrytitle>
					<manvolnum>3</manvolnum>
				</refmeta>

				<refnamediv>
					<refname>lqr_carver_new</refname>
					<refname>lqr_carver_destroy</refname>
					<refpurpose>the &carv_obj; object constructor and destructor</refpurpose>
				</refnamediv>

				<refsynopsisdiv>
					<funcsynopsis>
						<funcsynopsisinfo>#include &lt;lqr.h></funcsynopsisinfo>
						<funcprototype>
							<funcdef>LqrCarver* <function>lqr_carver_new</function></funcdef>
							<paramdef>guchar* <parameter>buffer</parameter></paramdef>
							<paramdef>gint <parameter>width</parameter></paramdef>
							<paramdef>gint <parameter>height</parameter></paramdef>
							<paramdef>gint <parameter>bpp</parameter></paramdef>
						</funcprototype>
						<funcprototype>
							<funcdef>void <function>lqr_carver_destroy</function></funcdef>
							<paramdef>LqrCarver* <parameter>carver</parameter></paramdef>
						</funcprototype>
					</funcsynopsis>
				</refsynopsisdiv>

				<refsect1>
					<title>Constructor</title>

					<refsect2>
						<title>Description</title>
						<para>
							The function <function>lqr_carver_new</function> creates a new
							&carv_obj; object from an RGB image of size &param_w; * &param_h;
							with &param_bpp; colour channels.
						</para>
						<para>
							The image must be stored in 
							<parameter>buffer</parameter> as a plain array of <type>unsigned chars</type>,
							ordered by row, then by column, then by colour channel.
						</para>
						<para>
							The buffer will be incorporated into the &carv_obj; object and
							must not be accessed any more
						</para>
					</refsect2>
					<refsect2>
						<title>Return value</title>
						<para>
							The return value is the address of the newly created &carv_obj; object, or
							<returnvalue>NULL</returnvalue> in case of failure.
						</para>
					</refsect2>
				</refsect1>

				<refsect1>
					<title>Destructor</title>

					<refsect2>
						<title>Description</title>
						<para>
							The function <function>lqr_carver_destroy</function> destroys the &carv_obj;
							object pointed to by <parameter>carver</parameter>, and all of its attched
							components (visibility maps and attached carvers).
						</para>
					</refsect2>
				</refsect1>
			</refentry>

			<refentry id="ref-lqr-carver-init">
				<refmeta>
					<refentrytitle>&carv_obj; initialization</refentrytitle>
					<manvolnum>3</manvolnum>
				</refmeta>

				<refnamediv>
					<refname>lqr_carver_init</refname>
					<refpurpose>activates a &carv_obj; object</refpurpose>
				</refnamediv>

				<refsynopsisdiv>
					<funcsynopsis>
						<funcsynopsisinfo>#include &lt;lqr.h></funcsynopsisinfo>
						<funcprototype>
							<funcdef>LqrRetVal <function>lqr_carver_init</function></funcdef>
							<paramdef>LqrCarver* <parameter>carver</parameter></paramdef>
							<paramdef>gint <parameter>delta_x</parameter></paramdef>
							<paramdef>gfloat <parameter>rigidity</parameter></paramdef>
						</funcprototype>
					</funcsynopsis>
				</refsynopsisdiv>

				<refsect1>
					<title>Description</title>
					<para>
						The function <function>lqr_carver_init</function> initializes
						the &carv_obj; pointed to by <parameter>carver</parameter>, so
						that it can compute the visibility maps as
						needed upon calls of <function>lqr_carver_resize</function>.
					</para>
					<para>
						The parameter <parameter>delta_x</parameter> controls the maximum
						transversal step a seam can make. A value of 0 means straight seams.
						Normally, it is set to 1.
					</para>
					<para>
						The parameter <parameter>rigidity</parameter> can be used to add 
						a negative bias to non-straight seams, and it is normally set to 0.
					</para>
					<para>
						Visibility maps must not be loaded when using this function,
						neither before nor after.
					</para>
				</refsect1>
				<refsect1>
					<title>Return value</title>
					<para>
						The return value follows the lqr library signalling system.
					</para>
				</refsect1>
			</refentry>

			<refentry id="ref-lqr-carver-resize-flatten">
				<refmeta>
					<refentrytitle>&carv_obj; resize and flatten</refentrytitle>
					<manvolnum>3</manvolnum>
				</refmeta>

				<refnamediv>
					<refname>lqr_carver_resize</refname>
					<refname>lqr_carver_flatten</refname>
					<refpurpose>manipulate a &carv_obj; object</refpurpose>
				</refnamediv>

				<refsynopsisdiv>
					<funcsynopsis>
						<funcsynopsisinfo>#include &lt;lqr.h></funcsynopsisinfo>
						<funcprototype>
							<funcdef>LqrRetVal <function>lqr_carver_resize</function></funcdef>
							<paramdef>LqrCarver* <parameter>carver</parameter></paramdef>
							<paramdef>gint <parameter>new_width</parameter></paramdef>
							<paramdef>gint <parameter>new_heigth</parameter></paramdef>
						</funcprototype>
						<funcprototype>
							<funcdef>LqrRetVal <function>lqr_carver_flatten</function></funcdef>
							<paramdef>LqrCarver* <parameter>carver</parameter></paramdef>
						</funcprototype>
					</funcsynopsis>
				</refsynopsisdiv>

				<refsect1>
					<title>Description</title>
					<para>
					</para>
				</refsect1>
				<refsect1>
					<title>Return value</title>
					<para>
						The return value follows the lqr library signalling system.
					</para>
				</refsect1>
			</refentry>

			<refentry id="ref-lqr-carver-scan">
				<refmeta>
					<refentrytitle>&carv_obj; readout</refentrytitle>
					<manvolnum>3</manvolnum>
				</refmeta>

				<refnamediv>
					<refname>lqr_carver_scan_reset</refname>
					<refname>lqr_carver_scan</refname>
					<refname>lqr_carver_scan_by_row</refname>
					<refname>lqr_carver_scan_line</refname>
					<refpurpose>read out a multi-size image</refpurpose>
				</refnamediv>

				<refsynopsisdiv>
					<funcsynopsis>
						<funcsynopsisinfo>#include &lt;lqr.h></funcsynopsisinfo>
						<funcprototype>
							<funcdef>void <function>lqr_carver_scan_reset</function></funcdef>
							<paramdef>LqrCarver* <parameter>carver</parameter></paramdef>
						</funcprototype>
						<funcprototype>
							<funcdef>gboolean <function>lqr_carver_scan</function></funcdef>
							<paramdef>LqrCarver* <parameter>carver</parameter></paramdef>
							<paramdef>gint* <parameter>x</parameter></paramdef>
							<paramdef>gint* <parameter>y</parameter></paramdef>
							<paramdef>gint** <parameter>rgb</parameter></paramdef>
						</funcprototype>
						<funcprototype>
							<funcdef>gboolean <function>lqr_carver_scan_by_row</function></funcdef>
							<paramdef>LqrCarver* <parameter>carver</parameter></paramdef>
						</funcprototype>
						<funcprototype>
							<funcdef>gboolean <function>lqr_carver_scan_line</function></funcdef>
							<paramdef>LqrCarver* <parameter>carver</parameter></paramdef>
							<paramdef>gint* <parameter>n</parameter></paramdef>
							<paramdef>gint** <parameter>rgb</parameter></paramdef>
						</funcprototype>
					</funcsynopsis>
				</refsynopsisdiv>

				<refsect1>
					<title>Description</title>
					<para>
					</para>
				</refsect1>
				<refsect1>
					<title>Return value</title>
					<para>
					</para>
				</refsect1>
			</refentry>

			<refentry id="ref-lqr-carver-get">
				<refmeta>
					<refentrytitle>Get &carv_obj; values</refentrytitle>
					<manvolnum>3</manvolnum>
				</refmeta>

				<refnamediv>
					<refname>lqr_carver_get_width</refname>
					<refname>lqr_carver_get_height</refname>
					<refname>lqr_carver_get_bpp</refname>
					<refpurpose>get various &carv_obj; object quantities</refpurpose>
				</refnamediv>

				<refsynopsisdiv>
					<funcsynopsis>
						<funcsynopsisinfo>#include &lt;lqr.h></funcsynopsisinfo>
						<funcprototype>
							<funcdef>gint <function>lqr_carver_get_width</function></funcdef>
							<paramdef>LqrCarver* <parameter>carver</parameter></paramdef>
						</funcprototype>
						<funcprototype>
							<funcdef>gint <function>lqr_carver_get_heigth</function></funcdef>
							<paramdef>LqrCarver* <parameter>carver</parameter></paramdef>
						</funcprototype>
						<funcprototype>
							<funcdef>gint <function>lqr_carver_get_bpp</function></funcdef>
							<paramdef>LqrCarver* <parameter>carver</parameter></paramdef>
						</funcprototype>
					</funcsynopsis>
				</refsynopsisdiv>

				<refsect1>
					<title>Description</title>
					<para>
					</para>
				</refsect1>
				<refsect1>
					<title>Return value</title>
					<para>
					</para>
				</refsect1>
			</refentry>

			<refentry id="ref-lqr-carver-set">
				<refmeta>
					<refentrytitle>Set &carv_obj; values</refentrytitle>
					<manvolnum>3</manvolnum>
				</refmeta>

				<refnamediv>
					<refname>lqr_carver_set_gradient_function</refname>
					<refname>lqr_carver_set_resize_order</refname>
					<refname>lqr_carver_set_dump_vmaps</refname>
					<refname>lqr_carver_set_progress</refname>
					<refpurpose>set various &carv_obj; object attributes</refpurpose>
				</refnamediv>

				<refsynopsisdiv>
					<funcsynopsis>
						<funcsynopsisinfo>#include &lt;lqr.h></funcsynopsisinfo>
						<funcprototype>
							<funcdef>void <function>lqr_carver_set_gradient_fucntion</function></funcdef>
							<paramdef>LqrCarver* <parameter>carver</parameter></paramdef>
							<paramdef>LqrGradFuncType <parameter>gf_ind</parameter></paramdef>
						</funcprototype>
						<funcprototype>
							<funcdef>void <function>lqr_carver_set_resize_order</function></funcdef>
							<paramdef>LqrCarver* <parameter>carver</parameter></paramdef>
							<paramdef>LqrResizeOrder <parameter>resize_order</parameter></paramdef>
						</funcprototype>
						<funcprototype>
							<funcdef>void <function>lqr_carver_set_dump_vmaps</function></funcdef>
							<paramdef>LqrCarver* <parameter>carver</parameter></paramdef>
						</funcprototype>
						<funcprototype>
							<funcdef>void <function>lqr_carver_set_progress</function></funcdef>
							<paramdef>LqrCarver* <parameter>carver</parameter></paramdef>
							<paramdef>LqrProgress* <parameter>p</parameter></paramdef>
						</funcprototype>
					</funcsynopsis>
				</refsynopsisdiv>

				<refsect1>
					<title>Description</title>
					<para>
					</para>
				</refsect1>
				<refsect1>
					<title>Return value</title>
					<para>
					</para>
				</refsect1>
			</refentry>

			<refentry id="ref-lqr-carver-attach">
				<refmeta>
					<refentrytitle>Attach carvers</refentrytitle>
					<manvolnum>3</manvolnum>
				</refmeta>

				<refnamediv>
					<refname>lqr_carver_attach</refname>
					<refpurpose>attach a &carv_obj; to another &carv_obj;</refpurpose>
				</refnamediv>

				<refsynopsisdiv>
					<funcsynopsis>
						<funcsynopsisinfo>#include &lt;lqr.h></funcsynopsisinfo>
						<funcprototype>
							<funcdef>LqrRetVal <function>lqr_carver_attach</function></funcdef>
							<paramdef>LqrCarver* <parameter>carver</parameter></paramdef>
						</funcprototype>
					</funcsynopsis>
				</refsynopsisdiv>

				<refsect1>
					<title>Description</title>
					<para>
					</para>
				</refsect1>
				<refsect1>
					<title>Return value</title>
					<para>
						The return value follows the lqr library signalling system.
					</para>
				</refsect1>
			</refentry>

			<refentry id="ref-lqr-carver-lists">
				<refmeta>
					<refentrytitle>Get attached carvers</refentrytitle>
					<manvolnum>3</manvolnum>
				</refmeta>

				<refnamediv>
					<refname>lqr_carver_list_start</refname>
					<refname>lqr_carver_list_current</refname>
					<refname>lqr_carver_list_next</refname>
					<refname>lqr_carver_list_foreach</refname>
					<refpurpose>get &carv_obj; objects attached to another &carv_obj;</refpurpose>
				</refnamediv>

				<refsynopsisdiv>
					<funcsynopsis>
						<funcsynopsisinfo>#include &lt;lqr.h></funcsynopsisinfo>
						<funcprototype>
							<funcdef>LqrCarverList* <function>lqr_carver_list_start</function></funcdef>
							<paramdef>LqrCarver* <parameter>carver</parameter></paramdef>
						</funcprototype>
						<funcprototype>
							<funcdef>LqrCarver* <function>lqr_carver_list_current</function></funcdef>
							<paramdef>LqrCarverList* <parameter>list</parameter></paramdef>
						</funcprototype>
						<funcprototype>
							<funcdef>LqrCarverList <function>lqr_carver_list_next</function></funcdef>
							<paramdef>LqrCarverList* <parameter>list</parameter></paramdef>
						</funcprototype>
						<funcprototype>
							<funcdef>LqrRetVal <function>lqr_carver_list_foreach</function></funcdef>
							<paramdef>LqrCarverList* <parameter>list</parameter></paramdef>
							<paramdef>LqrCarverFunc <parameter>func</parameter></paramdef>
							<paramdef>LqrDataTok <parameter>data</parameter></paramdef>
						</funcprototype>
					</funcsynopsis>
				</refsynopsisdiv>

				<refsect1>
					<title>Description</title>
					<para>
					</para>
				</refsect1>
				<refsect1>
					<title>Return value</title>
					<para>
					</para>
				</refsect1>
			</refentry>

		</sect1>


		<sect1 id="ref-vmaps">
			<title>Visibiliy maps</title>

			<refentry id="ref-lqr-vmap-new">
				<refmeta>
					<refentrytitle>&vmap_obj; constructor and destructor</refentrytitle>
					<manvolnum>3</manvolnum>
				</refmeta>

				<refnamediv>
					<refname>lqr_vmap_new</refname>
					<refname>lqr_vmap_destroy</refname>
					<refpurpose>the &vmap_obj; object constructor and destructor</refpurpose>
				</refnamediv>

				<refsynopsisdiv>
					<funcsynopsis>
						<funcsynopsisinfo>#include &lt;lqr.h></funcsynopsisinfo>
						<funcprototype>
							<funcdef>LqrVMap* <function>lqr_vmap_new</function></funcdef>
							<paramdef>gint* <parameter>buffer</parameter></paramdef>
							<paramdef>gint <parameter>width</parameter></paramdef>
							<paramdef>gint <parameter>heigth</parameter></paramdef>
							<paramdef>gint <parameter>depth</parameter></paramdef>
							<paramdef>gint <parameter>orientation</parameter></paramdef>
						</funcprototype>
						<funcprototype>
							<funcdef>void <function>lqr_vmap_destroy</function></funcdef>
							<paramdef>LqrVMap* <parameter>vmap</parameter></paramdef>
						</funcprototype>
					</funcsynopsis>
				</refsynopsisdiv>

				<refsect1>
					<title>Description</title>
					<para>
					</para>
				</refsect1>
				<refsect1>
					<title>Return value</title>
					<para>
					</para>
				</refsect1>
			</refentry>

			<refentry id="ref-lqr-vmap-get">
				<refmeta>
					<refentrytitle>Get &vmap_obj; values</refentrytitle>
					<manvolnum>3</manvolnum>
				</refmeta>

				<refnamediv>
					<refname>lqr_vmap_get_data</refname>
					<refname>lqr_vmap_get_width</refname>
					<refname>lqr_vmap_get_height</refname>
					<refname>lqr_vmap_get_depth</refname>
					<refname>lqr_vmap_get_orientation</refname>
					<refpurpose>get varous &vmap_obj; object quantities</refpurpose>
				</refnamediv>

				<refsynopsisdiv>
					<funcsynopsis>
						<funcsynopsisinfo>#include &lt;lqr.h></funcsynopsisinfo>
						<funcprototype>
							<funcdef>gint* <function>lqr_vmap_get_data</function></funcdef>
							<paramdef>LqrVMap* <parameter>vmap</parameter></paramdef>
						</funcprototype>
						<funcprototype>
							<funcdef>gint <function>lqr_vmap_get_width</function></funcdef>
							<paramdef>LqrVMap* <parameter>vmap</parameter></paramdef>
						</funcprototype>
						<funcprototype>
							<funcdef>gint <function>lqr_vmap_get_height</function></funcdef>
							<paramdef>LqrVMap* <parameter>vmap</parameter></paramdef>
						</funcprototype>
						<funcprototype>
							<funcdef>gint <function>lqr_vmap_get_depth</function></funcdef>
							<paramdef>LqrVMap* <parameter>vmap</parameter></paramdef>
						</funcprototype>
						<funcprototype>
							<funcdef>gint <function>lqr_vmap_get_orientation</function></funcdef>
							<paramdef>LqrVMap* <parameter>vmap</parameter></paramdef>
						</funcprototype>
					</funcsynopsis>
				</refsynopsisdiv>

				<refsect1>
					<title>Description</title>
					<para>
					</para>
				</refsect1>
				<refsect1>
					<title>Return value</title>
					<para>
					</para>
				</refsect1>
			</refentry>

			<refentry id="ref-lqr-vmap-dump">
				<refmeta>
					<refentrytitle>&vmap_obj; dump and load</refentrytitle>
					<manvolnum>3</manvolnum>
				</refmeta>

				<refnamediv>
					<refname>lqr_vmap_dump</refname>
					<refname>lqr_vmap_internal_dump</refname>
					<refname>lqr_vmap_load</refname>
					<refpurpose>dump and load &vmap_obj; objects</refpurpose>
				</refnamediv>

				<refsynopsisdiv>
					<funcsynopsis>
						<funcsynopsisinfo>#include &lt;lqr.h></funcsynopsisinfo>
						<funcprototype>
							<funcdef>LqrVMap* <function>lqr_vmap_dump</function></funcdef>
							<paramdef>LqrCarver* <parameter>carver</parameter></paramdef>
						</funcprototype>
						<funcprototype>
							<funcdef>LqrRetVal <function>lqr_vmap_internal_dump</function></funcdef>
							<paramdef>LqrCarver* <parameter>carver</parameter></paramdef>
						</funcprototype>
						<funcprototype>
							<funcdef>LqrRetVal <function>lqr_vmap_load</function></funcdef>
							<paramdef>LqrCarver* <parameter>carver</parameter></paramdef>
							<paramdef>LqrVMap* <parameter>vmap</parameter></paramdef>
						</funcprototype>
					</funcsynopsis>
				</refsynopsisdiv>

				<refsect1>
					<title>Description</title>
					<para>
					</para>
				</refsect1>
				<refsect1>
					<title>Return value</title>
					<para>
					</para>
				</refsect1>
			</refentry>

			<refentry id="ref-lqr-vmap-lists">
				<refmeta>
					<refentrytitle>Get dumped &vmap_obj;</refentrytitle>
					<manvolnum>3</manvolnum>
				</refmeta>

				<refnamediv>
					<refname>lqr_vmap_list_start</refname>
					<refname>lqr_vmap_list_current</refname>
					<refname>lqr_vmap_list_next</refname>
					<refname>lqr_vmap_list_foreach</refname>
					<refpurpose>get &vmap_obj; objects from a &carv_obj;</refpurpose>
				</refnamediv>
				<refsynopsisdiv>
					<funcsynopsis>
						<funcsynopsisinfo>#include &lt;lqr.h></funcsynopsisinfo>
						<funcprototype>
							<funcdef>LqrVMapList* <function>lqr_vmap_list_start</function></funcdef>
							<paramdef>LqrCarver* <parameter>carver</parameter></paramdef>
						</funcprototype>
						<funcprototype>
							<funcdef>LqrVMap <function>lqr_vmap_list_current</function></funcdef>
							<paramdef>LqrVMapList* <parameter>list</parameter></paramdef>
						</funcprototype>
						<funcprototype>
							<funcdef>LqrVMapList <function>lqr_vmap_list_next</function></funcdef>
							<paramdef>LqrVMapList* <parameter>list</parameter></paramdef>
						</funcprototype>
						<funcprototype>
							<funcdef>LqrRetVal <function>lqr_vmap_list_foreach</function></funcdef>
							<paramdef>LqrVMapList* <parameter>list</parameter></paramdef>
							<paramdef>LqrVMapFunc <parameter>func</parameter></paramdef>
							<paramdef>gpointer <parameter>data</parameter></paramdef>
						</funcprototype>
					</funcsynopsis>
				</refsynopsisdiv>

				<refsect1>
					<title>Description</title>
					<para>
					</para>
				</refsect1>
				<refsect1>
					<title>Return value</title>
					<para>
					</para>
				</refsect1>
			</refentry>
		</sect1>

		<sect1 id="ref-bias">
			<title>Bias</title>

			<refentry id="ref-lqr-bias-add">
				<refmeta>
					<refentrytitle>Add a bias to a &carv_obj;</refentrytitle>
					<manvolnum>3</manvolnum>
				</refmeta>

				<refnamediv>
					<refname>lqr_carver_bias_add</refname>
					<refname>lqr_carver_bias_add_area</refname>
					<refpurpose>update a &carv_obj; bias by reading a buffer</refpurpose>
				</refnamediv>

				<refsynopsisdiv>
					<funcsynopsis>
						<funcsynopsisinfo>#include &lt;lqr.h></funcsynopsisinfo>
						<funcprototype>
							<funcdef>LqrRetVal <function>lqr_carver_bias_add</function></funcdef>
							<paramdef>LqrCarver* <parameter>carver</parameter></paramdef>
							<paramdef>gdouble* <parameter>buffer</parameter></paramdef>
							<paramdef>gint <parameter>bias_factor</parameter></paramdef>
						</funcprototype>
						<funcprototype>
							<funcdef>LqrRetVal <function>lqr_carver_bias_add_area</function></funcdef>
							<paramdef>LqrCarver* <parameter>carver</parameter></paramdef>
							<paramdef>gdouble* <parameter>buffer</parameter></paramdef>
							<paramdef>gint <parameter>bias_factor</parameter></paramdef>
							<paramdef>gint <parameter>width</parameter></paramdef>
							<paramdef>gint <parameter>height</parameter></paramdef>
							<paramdef>gint <parameter>x_off</parameter></paramdef>
							<paramdef>gint <parameter>y_off</parameter></paramdef>
						</funcprototype>
					</funcsynopsis>
				</refsynopsisdiv>

				<refsect1>
					<title>Description</title>
					<para>
					</para>
				</refsect1>
				<refsect1>
					<title>Return value</title>
					<para>
					</para>
				</refsect1>
			</refentry>

			<refentry id="ref-lqr-bias-add-rgb">
				<refmeta>
					<refentrytitle>Read the bias from an image</refentrytitle>
					<manvolnum>3</manvolnum>
				</refmeta>

				<refnamediv>
					<refname>lqr_carver_bias_add_rgb</refname>
					<refname>lqr_carver_bias_add_rgb_area</refname>
					<refpurpose>update a &carv_obj; bias by reading an RGB image</refpurpose>
				</refnamediv>

				<refsynopsisdiv>
					<funcsynopsis>
						<funcsynopsisinfo>#include &lt;lqr.h></funcsynopsisinfo>
						<funcprototype>
							<funcdef>LqrRetVal <function>lqr_carver_bias_add_rgb</function></funcdef>
							<paramdef>LqrCarver* <parameter>carver</parameter></paramdef>
							<paramdef>gdouble* <parameter>buffer</parameter></paramdef>
							<paramdef>gint <parameter>bias_factor</parameter></paramdef>
							<paramdef>gint <parameter>bpp</parameter></paramdef>
						</funcprototype>
						<funcprototype>
							<funcdef>LqrRetVal <function>lqr_carver_bias_add_area</function></funcdef>
							<paramdef>LqrCarver* <parameter>carver</parameter></paramdef>
							<paramdef>gdouble* <parameter>buffer</parameter></paramdef>
							<paramdef>gint <parameter>bias_factor</parameter></paramdef>
							<paramdef>gint <parameter>bpp</parameter></paramdef>
							<paramdef>gint <parameter>width</parameter></paramdef>
							<paramdef>gint <parameter>height</parameter></paramdef>
							<paramdef>gint <parameter>x_off</parameter></paramdef>
							<paramdef>gint <parameter>y_off</parameter></paramdef>
						</funcprototype>
					</funcsynopsis>
				</refsynopsisdiv>

				<refsect1>
					<title>Description</title>
					<para>
					</para>
				</refsect1>
				<refsect1>
					<title>Return value</title>
					<para>
					</para>
				</refsect1>
			</refentry>
		</sect1>

		<sect1 id="ref-progress">
			<title>Progress reports</title>

			<refentry id="ref-lqr-progress-new">
				<refmeta>
					<refentrytitle>&prog_obj; constructor</refentrytitle>
					<manvolnum>3</manvolnum>
				</refmeta>

				<refnamediv>
					<refname>lqr_progress_new</refname>
					<refpurpose>the &prog_obj; object constructor</refpurpose>
				</refnamediv>

				<refsynopsisdiv>
					<funcsynopsis>
						<funcsynopsisinfo>#include &lt;lqr.h></funcsynopsisinfo>
						<funcprototype>
							<funcdef>LqrProgress* <function>lqr_progress_new</function></funcdef>
							<void></void>
						</funcprototype>
					</funcsynopsis>
				</refsynopsisdiv>

				<refsect1>
					<title>Description</title>
					<para>
					</para>
				</refsect1>
				<refsect1>
					<title>Return value</title>
					<para>
					</para>
				</refsect1>
			</refentry>

			<refentry id="ref-lqr-progress-set-hooks">
				<refmeta>
					<refentrytitle>Set &prog_obj; hooks</refentrytitle>
					<manvolnum>3</manvolnum>
				</refmeta>

				<refnamediv>
					<refname>lqr_progress_set_init</refname>
					<refname>lqr_progress_set_update</refname>
					<refname>lqr_progress_set_end</refname>
					<refpurpose>execude custom code during the resizing operations</refpurpose>
				</refnamediv>

				<refsynopsisdiv>
					<funcsynopsis>
						<funcsynopsisinfo>#include &lt;lqr.h></funcsynopsisinfo>
						<funcprototype>
							<funcdef>LqrRetVal <function>lqr_progress_set_init</function></funcdef>
							<paramdef>LqrProgress* <parameter>p</parameter></paramdef>
							<paramdef>LqrProgressFuncInit <parameter>init_func</parameter></paramdef>
						</funcprototype>
						<funcprototype>
							<funcdef>LqrRetVal <function>lqr_progress_set_update</function></funcdef>
							<paramdef>LqrProgress* <parameter>p</parameter></paramdef>
							<paramdef>LqrProgressFuncUpdate <parameter>update_func</parameter></paramdef>
						</funcprototype>
						<funcprototype>
							<funcdef>LqrRetVal <function>lqr_progress_set_end</function></funcdef>
							<paramdef>LqrProgress* <parameter>p</parameter></paramdef>
							<paramdef>LqrProgressFuncEnd <parameter>end_func</parameter></paramdef>
						</funcprototype>
					</funcsynopsis>
				</refsynopsisdiv>

				<refsect1>
					<title>Description</title>
					<para>
					</para>
				</refsect1>
				<refsect1>
					<title>Return value</title>
					<para>
					</para>
				</refsect1>
			</refentry>

			<refentry id="ref-lqr-progress-set-params">
				<refmeta>
					<refentrytitle>Set &prog_obj; parameters</refentrytitle>
					<manvolnum>3</manvolnum>
				</refmeta>

				<refnamediv>
					<refname>lqr_progress_set_update_step</refname>
					<refname>lqr_progress_set_init_width_message</refname>
					<refname>lqr_progress_set_end_width_message</refname>
					<refname>lqr_progress_set_init_height_message</refname>
					<refname>lqr_progress_set_end_height_message</refname>
					<refpurpose>setup update step and output messages</refpurpose>
				</refnamediv>

				<refsynopsisdiv>
					<funcsynopsis>
						<funcsynopsisinfo>#include &lt;lqr.h></funcsynopsisinfo>
						<funcprototype>
							<funcdef>LqrRetVal <function>lqr_progress_set_update_step</function></funcdef>
							<paramdef>LqrProgress* <parameter>p</parameter></paramdef>
							<paramdef>gfloat <parameter>update_step</parameter></paramdef>
						</funcprototype>
						<funcprototype>
							<funcdef>LqrRetVal <function>lqr_progress_set_init_width_message</function></funcdef>
							<paramdef>LqrProgress* <parameter>p</parameter></paramdef>
							<paramdef>const guchar* <parameter>message</parameter></paramdef>
						</funcprototype>
						<funcprototype>
							<funcdef>LqrRetVal <function>lqr_progress_set_end_width_message</function></funcdef>
							<paramdef>LqrProgress* <parameter>p</parameter></paramdef>
							<paramdef>const guchar* <parameter>message</parameter></paramdef>
						</funcprototype>
						<funcprototype>
							<funcdef>LqrRetVal <function>lqr_progress_set_init_width_message</function></funcdef>
							<paramdef>LqrProgress* <parameter>p</parameter></paramdef>
							<paramdef>const guchar* <parameter>message</parameter></paramdef>
						</funcprototype>
						<funcprototype>
							<funcdef>LqrRetVal <function>lqr_progress_set_end_height_message</function></funcdef>
							<paramdef>LqrProgress* <parameter>p</parameter></paramdef>
							<paramdef>const guchar* <parameter>message</parameter></paramdef>
						</funcprototype>
					</funcsynopsis>
				</refsynopsisdiv>

				<refsect1>
					<title>Description</title>
					<para>
					</para>
				</refsect1>
				<refsect1>
					<title>Return value</title>
					<para>
					</para>
				</refsect1>
			</refentry>
		</sect1>
	</chapter>


	<chapter id="references">
		<title>References</title>

		<para>
			The library implements the algorithm described in the paper
			"Seam Carving for Content-Aware Image Resizing"
			by Shai Avidan and Ariel Shamir, which can be found at
			<ulink url="http://www.faculty.idc.ac.il/arik/imret.pdf">here</ulink>
		</para>
	</chapter>

	<appendix id="gfdl">
	  <title>GNU Free Documentation License</title>
	  <para>
	    Copyright (C) 2000, 2001, 2002 Free Software Foundation,
	    <abbrev>Inc.</abbrev> 51 Franklin <abbrev>St</abbrev>, Fifth Floor,
	    Boston, <abbrev>MA</abbrev> 02110-1301 <abbrev
	    role="initialism">USA</abbrev>.  Everyone is permitted to copy and
	    distribute verbatim copies of this license document, but changing it is
	    not allowed.
	  </para>
	  <bridgehead id="Preamble" renderas="sect1">
	    0. PREAMBLE
	  </bridgehead>
	  <para>
	    The purpose of this License is to make a manual, textbook, or other
	    functional and useful document "free" in the sense of freedom: to assure
	    everyone the effective freedom to copy and redistribute it, with or
	    without modifying it, either commercially or noncommercially.
	    Secondarily, this License preserves for the author and publisher a way to
	    get credit for their work, while not being considered responsible for
	    modifications made by others.
	  </para>
	  <para>
	    This License is a kind of "copyleft", which means that derivative works of
	    the document must themselves be free in the same sense.  It complements
	    the GNU General Public License, which is a copyleft license designed for
	    free software.
	  </para>
	  <para>
	    We have designed this License in order to use it for manuals for free
	    software, because free software needs free documentation: a free program
	    should come with manuals providing the same freedoms that the software
	    does.  But this License is not limited to software manuals; it can be used
	    for any textual work, regardless of subject matter or whether it is
	    published as a printed book.  We recommend this License principally for
	    works whose purpose is instruction or reference.</para>
	  <bridgehead id="Definitions" renderas="sect1">
	    1. APPLICABILITY AND DEFINITIONS
	  </bridgehead>
	  <para>
	    This License applies to any manual or other work, in any medium, that
	    contains a notice placed by the copyright holder saying it can be
	    distributed under the terms of this License.  Such a notice grants a
	    world-wide, royalty-free license, unlimited in duration, to use that work
	    under the conditions stated herein.  The "Document", below, refers to any
	    such manual or work.  Any member of the public is a licensee, and is
	    addressed as "you".  You accept the license if you copy, modify or
	    distribute the work in a way requiring permission under copyright
	    law.
	  </para>
	  <para>
	    A "Modified Version" of the Document means any work containing the
	    Document or a portion of it, either copied verbatim, or with modifications
	    and/or translated into another language.
	  </para>
	  <para>
	    A "Secondary Section" is a named appendix or a front-matter section of the
	    Document that deals exclusively with the relationship of the publishers or
	    authors of the Document to the Document's overall subject (or to related
	    matters) and contains nothing that could fall directly within that overall
	    subject.  (Thus, if the Document is in part a textbook of mathematics, a
	    Secondary Section may not explain any mathematics.)  The relationship
	    could be a matter of historical connection with the subject or with
	    related matters, or of legal, commercial, philosophical, ethical or
	    political position regarding them.
	  </para>
	  <para>
	    The "Invariant Sections" are certain Secondary Sections whose titles are
	    designated, as being those of Invariant Sections, in the notice that says
	    that the Document is released under this License.  If a section does not
	    fit the above definition of Secondary then it is not allowed to be
	    designated as Invariant.  The Document may contain zero Invariant
	    Sections.  If the Document does not identify any Invariant Sections then
	    there are none.
	  </para>
	  <para>
	    The "Cover Texts" are certain short passages of text that are listed, as
	    Front-Cover Texts or Back-Cover Texts, in the notice that says that the
	    Document is released under this License.  A Front-Cover Text may be at
	    most 5 words, and a Back-Cover Text may be at most 25 words.
	  </para>
	  <para>
	    A "Transparent" copy of the Document means a machine-readable copy,
	    represented in a format whose specification is available to the general
	    public, that is suitable for revising the document straightforwardly with
	    generic text editors or (for images composed of pixels) generic paint
	    programs or (for drawings) some widely available drawing editor, and that
	    is suitable for input to text formatters or for automatic translation to a
	    variety of formats suitable for input to text formatters.  A copy made in
	    an otherwise Transparent file format whose markup, or absence of markup,
	    has been arranged to thwart or discourage subsequent modification by
	    readers is not Transparent.  An image format is not Transparent if used
	    for any substantial amount of text.  A copy that is not "Transparent" is
	    called "Opaque".
	  </para>
	  <para>
	    Examples of suitable formats for Transparent copies include plain ASCII
	    without markup, Texinfo input format, LaTeX input format, SGML or XML
	    using a publicly available DTD, and standard-conforming simple HTML,
	    PostScript or PDF designed for human modification.  Examples of
	    transparent image formats include PNG, XCF and JPG.  Opaque formats
	    include proprietary formats that can be read and edited only by
	    proprietary word processors, SGML or XML for which the DTD and/or
	    processing tools are not generally available, and the machine-generated
	    HTML, PostScript or PDF produced by some word processors for output
	    purposes only.
	  </para>
	  <para>
	    The "Title Page" means, for a printed book, the title page itself, plus
	    such following pages as are needed to hold, legibly, the material this
	    License requires to appear in the title page.  For works in formats which
	    do not have any title page as such, "Title Page" means the text near the
	    most prominent appearance of the work's title, preceding the beginning of
	    the body of the text.
	  </para>
	  <para>
	    A section "Entitled XYZ" means a named subunit of the Document whose title
	    either is precisely XYZ or contains XYZ in parentheses following text that
	    translates XYZ in another language.  (Here XYZ stands for a specific
	    section name mentioned below, such as "Acknowledgements", "Dedications",
	    "Endorsements", or "History".)  To "Preserve the Title" of such a section
	    when you modify the Document means that it remains a section "Entitled
	    XYZ" according to this definition.
	  </para>
	  <para>
	    The Document may include Warranty Disclaimers next to the notice which
	    states that this License applies to the Document.  These Warranty
	    Disclaimers are considered to be included by reference in this License,
	    but only as regards disclaiming warranties: any other implication that
	    these Warranty Disclaimers may have is void and has no effect on the
	    meaning of this License.
	  </para>
	  <bridgehead id="VerbatimCopying" renderas="sect1">
	    2. VERBATIM COPYING
	  </bridgehead>
	  <para>
	    You may copy and distribute the Document in any medium, either
	    commercially or noncommercially, provided that this License, the copyright
	    notices, and the license notice saying this License applies to the
	    Document are reproduced in all copies, and that you add no other
	    conditions whatsoever to those of this License.  You may not use technical
	    measures to obstruct or control the reading or further copying of the
	    copies you make or distribute.  However, you may accept compensation in
	    exchange for copies.  If you distribute a large enough number of copies
	    you must also follow the conditions in section 3.
	  </para>
	  <para>
	    You may also lend copies, under the same conditions stated above, and you
	    may publicly display copies.
	  </para>
	  <bridgehead id="QuantityCopying" renderas="sect1">
	    3. COPYING IN QUANTITY
	  </bridgehead>
	  <para>
	    If you publish printed copies (or copies in media that commonly have
	    printed covers) of the Document, numbering more than 100, and the
	    Document's license notice requires Cover Texts, you must enclose the
	    copies in covers that carry, clearly and legibly, all these Cover Texts:
	    Front-Cover Texts on the front cover, and Back-Cover Texts on the back
	    cover.  Both covers must also clearly and legibly identify you as the
	    publisher of these copies.  The front cover must present the full title
	    with all words of the title equally prominent and visible.  You may add
	    other material on the covers in addition.  Copying with changes limited to
	    the covers, as long as they preserve the title of the Document and satisfy
	    these conditions, can be treated as verbatim copying in other
	    respects.
	  </para>
	  <para>
	    If the required texts for either cover are too voluminous to fit legibly,
	    you should put the first ones listed (as many as fit reasonably) on the
	    actual cover, and continue the rest onto adjacent pages.
	  </para>
	  <para>
	    If you publish or distribute Opaque copies of the Document numbering more
	    than 100, you must either include a machine-readable Transparent copy
	    along with each Opaque copy, or state in or with each Opaque copy a
	    computer-network location from which the general network-using public has
	    access to download using public-standard network protocols a complete
	    Transparent copy of the Document, free of added material.  If you use the
	    latter option, you must take reasonably prudent steps, when you begin
	    distribution of Opaque copies in quantity, to ensure that this Transparent
	    copy will remain thus accessible at the stated location until at least one
	    year after the last time you distribute an Opaque copy (directly or
	    through your agents or retailers) of that edition to the public.
	  </para>
	  <para>
	    It is requested, but not required, that you contact the authors of the
	    Document well before redistributing any large number of copies, to give
	    them a chance to provide you with an updated version of the
	    Document.
	  </para>
	  <bridgehead id="Modifications" renderas="sect1">
	    4. MODIFICATIONS
	  </bridgehead>
	  <para>
	    You may copy and distribute a Modified Version of the Document under the
	    conditions of sections 2 and 3 above, provided that you release the
	    Modified Version under precisely this License, with the Modified Version
	    filling the role of the Document, thus licensing distribution and
	    modification of the Modified Version to whoever possesses a copy of it.
	    In addition, you must do these things in the Modified Version:
	  </para>
	  <orderedlist numeration="upperalpha">
	    <listitem>
	      <simpara>
		Use in the Title Page (and on the covers, if any) a title distinct
		from that of the Document, and from those of previous versions (which
		should, if there were any, be listed in the History section of the
		Document).  You may use the same title as a previous version if the
		original publisher of that version gives permission.
		</simpara>
	    </listitem>
	    <listitem>
	      <simpara>
		List on the Title Page, as authors, one or more persons or entities
		responsible for authorship of the modifications in the Modified
		Version, together with at least five of the principal authors of the
		Document (all of its principal authors, if it has fewer than five),
		unless they release you from this requirement.
	      </simpara>
	    </listitem>
	    <listitem>
	      <simpara>
		State on the Title page the name of the publisher of the Modified
		Version, as the publisher.
	      </simpara>
	    </listitem>
	    <listitem>
	      <simpara>
		Preserve all the copyright notices of the Document.
	      </simpara>
	    </listitem>
	    <listitem>
	      <simpara>
		Add an appropriate copyright notice for your modifications adjacent to
		the other copyright notices.
	      </simpara>
	    </listitem>
	    <listitem>
	      <simpara>
		Include, immediately after the copyright notices, a license notice
		giving the public permission to use the Modified Version under the
		terms of this License, in the form shown in the Addendum below.
	      </simpara>
	    </listitem>
	    <listitem>
	      <simpara>
		Preserve in that license notice the full lists of Invariant Sections
		and required Cover Texts given in the Document's license notice.
	      </simpara>
	    </listitem>
	    <listitem>
	      <simpara>
		Include an unaltered copy of this License.
	      </simpara>
	    </listitem>
	    <listitem>
	      <simpara>
		Preserve the section Entitled "History", Preserve its Title, and add
		to it an item stating at least the title, year, new authors, and
		publisher of the Modified Version as given on the Title Page.  If
		there is no section Entitled "History" in the Document, create one
		stating the title, year, authors, and publisher of the Document as
		given on its Title Page, then add an item describing the Modified
		Version as stated in the previous sentence.
	      </simpara>
	    </listitem>
	    <listitem>
	      <simpara>
		Preserve the network location, if any, given in the Document for
		public access to a Transparent copy of the Document, and likewise the
		network locations given in the Document for previous versions it was
		based on.  These may be placed in the "History" section.  You may omit
		a network location for a work that was published at least four years
		before the Document itself, or if the original publisher of the
		version it refers to gives permission.
	      </simpara>
	    </listitem>
	    <listitem>
	      <simpara>
		For any section Entitled "Acknowledgements" or "Dedications", Preserve
		the Title of the section, and preserve in the section all the
		substance and tone of each of the contributor acknowledgements and/or
		dedications given therein.
	      </simpara>
	    </listitem>
	    <listitem>
	      <simpara>
		Preserve all the Invariant Sections of the Document, unaltered in
		their text and in their titles.  Section numbers or the equivalent are
		not considered part of the section titles.
	      </simpara>
	    </listitem>
	    <listitem>
	      <simpara>
		Delete any section Entitled "Endorsements".  Such a section may not be
		included in the Modified Version.
	      </simpara>
	    </listitem>
	    <listitem>
	      <simpara>
		Do not retitle any existing section to be Entitled "Endorsements" or
		to conflict in title with any Invariant Section.
	      </simpara>
	    </listitem>
	    <listitem>
	      <simpara>
		Preserve any Warranty Disclaimers.
	      </simpara>
	    </listitem>
	  </orderedlist>
	  <para>
	    If the Modified Version includes new front-matter sections or appendices
	    that qualify as Secondary Sections and contain no material copied from the
	    Document, you may at your option designate some or all of these sections
	    as invariant.  To do this, add their titles to the list of Invariant
	    Sections in the Modified Version's license notice.  These titles must be
	    distinct from any other section titles.
	  </para>
	  <para>
	    You may add a section Entitled "Endorsements", provided it contains
	    nothing but endorsements of your Modified Version by various parties--for
	    example, statements of peer review or that the text has been approved by
	    an organization as the authoritative definition of a standard.
	  </para>
	  <para>
	    You may add a passage of up to five words as a Front-Cover Text, and a
	    passage of up to 25 words as a Back-Cover Text, to the end of the list of
	    Cover Texts in the Modified Version.  Only one passage of Front-Cover Text
	    and one of Back-Cover Text may be added by (or through arrangements made
	    by) any one entity.  If the Document already includes a cover text for the
	    same cover, previously added by you or by arrangement made by the same
	    entity you are acting on behalf of, you may not add another; but you may
	    replace the old one, on explicit permission from the previous publisher
	    that added the old one.
	  </para>
	  <para>
	    The author(s) and publisher(s) of the Document do not by this License give
	    permission to use their names for publicity for or to assert or imply
	    endorsement of any Modified Version.
	  </para>
	  <bridgehead id="Combining" renderas="sect1">
	    5. COMBINING DOCUMENTS
	  </bridgehead>
	  <para>
	    You may combine the Document with other documents released under this
	    License, under the terms defined in section 4 above for modified versions,
	    provided that you include in the combination all of the Invariant Sections
	    of all of the original documents, unmodified, and list them all as
	    Invariant Sections of your combined work in its license notice, and that
	    you preserve all their Warranty Disclaimers.
	  </para>
	  <para>
	    The combined work need only contain one copy of this License, and multiple
	    identical Invariant Sections may be replaced with a single copy.  If there
	    are multiple Invariant Sections with the same name but different contents,
	    make the title of each such section unique by adding at the end of it, in
	    parentheses, the name of the original author or publisher of that section
	    if known, or else a unique number.  Make the same adjustment to the
	    section titles in the list of Invariant Sections in the license notice of
	    the combined work.
	  </para>
	  <para>
	    In the combination, you must combine any sections Entitled "History" in
	    the various original documents, forming one section Entitled "History";
	    likewise combine any sections Entitled "Acknowledgements", and any
	    sections Entitled "Dedications".  You must delete all sections Entitled
	    "Endorsements".
	  </para>
	  <bridgehead id="Collections" renderas="sect1">
	    6. COLLECTIONS OF DOCUMENTS
	  </bridgehead>
	  <para>
	    You may make a collection consisting of the Document and other documents
	    released under this License, and replace the individual copies of this
	    License in the various documents with a single copy that is included in
	    the collection, provided that you follow the rules of this License for
	    verbatim copying of each of the documents in all other respects.
	  </para>
	  <para>
	    You may extract a single document from such a collection, and distribute
	    it individually under this License, provided you insert a copy of this
	    License into the extracted document, and follow this License in all other
	    respects regarding verbatim copying of that document.
	  </para>
	  <bridgehead id="Aggregation" renderas="sect1">
	    7. AGGREGATION WITH INDEPENDENT WORKS
	  </bridgehead>
	  <para>
	    A compilation of the Document or its derivatives with other separate and
	    independent documents or works, in or on a volume of a storage or
	    distribution medium, is called an "aggregate" if the copyright resulting
	    from the compilation is not used to limit the legal rights of the
	    compilation's users beyond what the individual works permit.  When the
	    Document is included in an aggregate, this License does not apply to the
	    other works in the aggregate which are not themselves derivative works of
	    the Document.
	  </para>
	  <para>
	    If the Cover Text requirement of section 3 is applicable to these copies
	    of the Document, then if the Document is less than one half of the entire
	    aggregate, the Document's Cover Texts may be placed on covers that bracket
	    the Document within the aggregate, or the electronic equivalent of covers
	    if the Document is in electronic form.  Otherwise they must appear on
	    printed covers that bracket the whole aggregate.
	  </para>
	  <bridgehead id="Translation" renderas="sect1">
	    8. TRANSLATION
	  </bridgehead>
	  <para>
	    Translation is considered a kind of modification, so you may distribute
	    translations of the Document under the terms of section 4.  Replacing
	    Invariant Sections with translations requires special permission from
	    their copyright holders, but you may include translations of some or all
	    Invariant Sections in addition to the original versions of these Invariant
	    Sections.  You may include a translation of this License, and all the
	    license notices in the Document, and any Warranty Disclaimers, provided
	    that you also include the original English version of this License and the
	    original versions of those notices and disclaimers.  In case of a
	    disagreement between the translation and the original version of this
	    License or a notice or disclaimer, the original version will prevail.
	  </para>
	  <para>
	    If a section in the Document is Entitled "Acknowledgements",
	    "Dedications", or "History", the requirement (section 4) to Preserve its
	    Title (section 1) will typically require changing the actual title.
	  </para>
	  <bridgehead id="Termination" renderas="sect1">
	    9. TERMINATION
	  </bridgehead>
	  <para>
	    You may not copy, modify, sublicense, or distribute the Document except as
	    expressly provided for under this License.  Any other attempt to copy,
	    modify, sublicense or distribute the Document is void, and will
	    automatically terminate your rights under this License.  However, parties
	    who have received copies, or rights, from you under this License will not
	    have their licenses terminated so long as such parties remain in full
	    compliance.
	  </para>
	  <bridgehead id="FutureRevisions" renderas="sect1">
	    10. FUTURE REVISIONS OF THIS LICENSE
	  </bridgehead>
	  <para>
	    The Free Software Foundation may publish new, revised versions of the GNU
	    Free Documentation License from time to time.  Such new versions will be
	    similar in spirit to the present version, but may differ in detail to
	    address new problems or concerns.  See <ulink
	    url="http://www.gnu.org/copyleft/">http://www.gnu.org/copyleft/</ulink>.
	  </para>
	  <para>
	    Each version of the License is given a distinguishing version number.  If
	    the Document specifies that a particular numbered version of this License
	    "or any later version" applies to it, you have the option of following the
	    terms and conditions either of that specified version or of any later
	    version that has been published (not as a draft) by the Free Software
	    Foundation.  If the Document does not specify a version number of this
	    License, you may choose any version ever published (not as a draft) by the
	    Free Software Foundation.
	  </para>
	  <bridgehead id="HowToUse" renderas="sect1">
	    ADDENDUM: How to use this License for your documents
	  </bridgehead>
	  <para>
	    To use this License in a document you have written, include a copy of the
	    License in the document and put the following copyright and license
	    notices just after the title page:
	  </para>
	  <blockquote>
	    <para>
	      Copyright (C) YEAR YOUR NAME.
	    </para>
	    <para>
	      Permission is granted to copy, distribute and/or modify this document
	      under the terms of the GNU Free Documentation License, Version 1.2 or
	      any later version published by the Free Software Foundation; with no
	      Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.  A
	      copy of the license is included in the section entitled "GNU Free
	      Documentation License".
	    </para>
	  </blockquote>
	  <para>
	    If you have Invariant Sections, Front-Cover Texts and Back-Cover Texts,
	    replace the "with...Texts." line with this:
	  </para>
	  <blockquote>
	    <para>
	      with the Invariant Sections being LIST THEIR TITLES, with the
	      Front-Cover Texts being LIST, and with the Back-Cover Texts being LIST.
	    </para>
	  </blockquote>
	  <para>
	    If you have Invariant Sections without Cover Texts, or some other
	    combination of the three, merge those two alternatives to suit the
	    situation.
	  </para>
	  <para>
	    If your document contains nontrivial examples of program code, we
	    recommend releasing these examples in parallel under your choice of free
	    software license, such as the GNU General Public License, to permit their
	    use in free software.
	  </para>
	</appendix>

</book>
		

